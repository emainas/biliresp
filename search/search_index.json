{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"biliresp Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for Terachem, a linear-ESP (raw, unrestrained) charge constraint optimization solver, examples for validating dipoles, and a mass-weighted center-of-mass calculator that can operate on RESP or xyz geometries. Use the navigation to find quick-start installation instructions and focused walkthroughs for the two shipped command-line entry points: Fitting charges with the linear ESP solver. Cross-validating dipoles between RESP and fitted charges (and reconciling centers of mass) using the helper in scripts/print_dipoles.py or the reference implementation in tests/test_dipole.py .","title":"Home"},{"location":"#biliresp","text":"Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for Terachem, a linear-ESP (raw, unrestrained) charge constraint optimization solver, examples for validating dipoles, and a mass-weighted center-of-mass calculator that can operate on RESP or xyz geometries. Use the navigation to find quick-start installation instructions and focused walkthroughs for the two shipped command-line entry points: Fitting charges with the linear ESP solver. Cross-validating dipoles between RESP and fitted charges (and reconciling centers of mass) using the helper in scripts/print_dipoles.py or the reference implementation in tests/test_dipole.py .","title":"biliresp"},{"location":"getting-started/","text":"Getting Started Prerequisites Python 3.9 or newer. A virtual environment to isolate dependencies is recommended. python -m venv .venv source .venv/bin/activate Install the package Install the project in editable mode so that local code changes are reflected immediately: python -m pip install -e . Run the test suite Pytest expects the src/ directory on PYTHONPATH so the package can be located: PYTHONPATH=src pytest -s tests Use -k to narrow to a single test module when iterating, for example: PYTHONPATH=src pytest -s tests/test_dipole.py","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Python 3.9 or newer. A virtual environment to isolate dependencies is recommended. python -m venv .venv source .venv/bin/activate","title":"Prerequisites"},{"location":"getting-started/#install-the-package","text":"Install the project in editable mode so that local code changes are reflected immediately: python -m pip install -e .","title":"Install the package"},{"location":"getting-started/#run-the-test-suite","text":"Pytest expects the src/ directory on PYTHONPATH so the package can be located: PYTHONPATH=src pytest -s tests Use -k to narrow to a single test module when iterating, for example: PYTHONPATH=src pytest -s tests/test_dipole.py","title":"Run the test suite"},{"location":"symmetry/","text":"Symmetry Analysis The symmetry module converts molecular structures into networkx graphs and applies Weisfeiler\u2013Lehman (WL) refinement to discover atoms that share identical local environments. This is particularly helpful when analysing RESP results, because the buckets returned by the WL procedure highlight atoms that can share constrained charges. from pathlib import Path from symmetry import buckets_from_pdb buckets = buckets_from_pdb(Path(\"data/raw/1.pose.pdb\"), radius=10) print(f\"Identified {len(buckets)} equivalence classes\") Each bucket contains the indices of atoms that are indistinguishable after r rounds of WL refinement. Increase radius when you need a deeper comparison of atomic environments. Radius 10 Radius 15 The figure above starts from the hydrogen-less network of the biliverdin fragment. The colourings correspond to WL buckets evaluated at radii 10 and 15, respectively.","title":"Symmetry"},{"location":"symmetry/#symmetry-analysis","text":"The symmetry module converts molecular structures into networkx graphs and applies Weisfeiler\u2013Lehman (WL) refinement to discover atoms that share identical local environments. This is particularly helpful when analysing RESP results, because the buckets returned by the WL procedure highlight atoms that can share constrained charges. from pathlib import Path from symmetry import buckets_from_pdb buckets = buckets_from_pdb(Path(\"data/raw/1.pose.pdb\"), radius=10) print(f\"Identified {len(buckets)} equivalence classes\") Each bucket contains the indices of atoms that are indistinguishable after r rounds of WL refinement. Increase radius when you need a deeper comparison of atomic environments. Radius 10 Radius 15 The figure above starts from the hydrogen-less network of the biliverdin fragment. The colourings correspond to WL buckets evaluated at radii 10 and 15, respectively.","title":"Symmetry Analysis"},{"location":"workflows/dipole-cross-validation/","text":"Dipole Cross-Validation The helper implemented in scripts/print_dipoles.py (and mirrored inside tests/test_dipole.py ) compares three sets of dipole moments for a selected frame of a RESP run: QM dipole reported directly by TeraChem. TeraChem dipole reconstructed from the ESP-unrestrained charges written in resp.out . Lagrange dipole generated from the fitted charges returned by the linear ESP solver. The helper parses the frame in resp.out , converts the logged center of mass to bohr, and computes dipoles in Debye via: \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] with coordinates expressed in bohr. It also reports a mass-weighted center of mass derived from the supplied geometry .xyz file; you can override the coordinates (\u00c5 or bohr) when calling center_of_mass_bohr_from_xyz if you need to reuse RESP geometries directly. The return dictionary contains each dipole vector/magnitude, their deltas relative to the QM reference, and both COM estimates. Script entry point scripts/print_dipoles.py bundles the full workflow: python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz data/raw/1.pose.xyz 78 --frame -1 The script builds the linear system, fits charges with the explicit Lagrange projection, and prints the QM, TeraChem, and Lagrange dipoles plus their deltas. --frame chooses which RESP frame to analyze ( -1 = last). The geometry .xyz supplies element ordering for mass lookup when computing the mass-weighted COM. Typical output QM (from resp.out log) vector (Debye): [-0.123 ...] |\u03bc| (Debye): 2.345678 Terachem charges (RESP log) vector (Debye): [-0.121 ...] |\u03bc| (Debye): 2.346100 \u0394 vector vs QM (Debye): [0.002 ...] \u0394|\u03bc| vs QM (Debye): 0.000422 Lagrange multiplier fit (explicit) vector (Debye): [-0.120 ...] |\u03bc| (Debye): 2.345900 \u0394 vector vs QM (Debye): [0.003 ...] \u0394|\u03bc| vs QM (Debye): 0.000222 Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows. Parity visualisation The example notebook in notebooks/ produces a parity plot comparing the QM dipole magnitude against the TeraChem ESP reconstruction across every frame. The figure below highlights the excellent agreement and annotates the RMSE. Colours denote the absolute deviation |\u0394| in Debye. Programmatic use See tests/test_dipole.py for a complete, importable example. The test implements _three_dipoles_for_frame inline so you can copy it into your own workflow if the CLI output is not sufficient.","title":"Dipole Cross-Validation"},{"location":"workflows/dipole-cross-validation/#dipole-cross-validation","text":"The helper implemented in scripts/print_dipoles.py (and mirrored inside tests/test_dipole.py ) compares three sets of dipole moments for a selected frame of a RESP run: QM dipole reported directly by TeraChem. TeraChem dipole reconstructed from the ESP-unrestrained charges written in resp.out . Lagrange dipole generated from the fitted charges returned by the linear ESP solver. The helper parses the frame in resp.out , converts the logged center of mass to bohr, and computes dipoles in Debye via: \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] with coordinates expressed in bohr. It also reports a mass-weighted center of mass derived from the supplied geometry .xyz file; you can override the coordinates (\u00c5 or bohr) when calling center_of_mass_bohr_from_xyz if you need to reuse RESP geometries directly. The return dictionary contains each dipole vector/magnitude, their deltas relative to the QM reference, and both COM estimates.","title":"Dipole Cross-Validation"},{"location":"workflows/dipole-cross-validation/#script-entry-point","text":"scripts/print_dipoles.py bundles the full workflow: python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz data/raw/1.pose.xyz 78 --frame -1 The script builds the linear system, fits charges with the explicit Lagrange projection, and prints the QM, TeraChem, and Lagrange dipoles plus their deltas. --frame chooses which RESP frame to analyze ( -1 = last). The geometry .xyz supplies element ordering for mass lookup when computing the mass-weighted COM.","title":"Script entry point"},{"location":"workflows/dipole-cross-validation/#typical-output","text":"QM (from resp.out log) vector (Debye): [-0.123 ...] |\u03bc| (Debye): 2.345678 Terachem charges (RESP log) vector (Debye): [-0.121 ...] |\u03bc| (Debye): 2.346100 \u0394 vector vs QM (Debye): [0.002 ...] \u0394|\u03bc| vs QM (Debye): 0.000422 Lagrange multiplier fit (explicit) vector (Debye): [-0.120 ...] |\u03bc| (Debye): 2.345900 \u0394 vector vs QM (Debye): [0.003 ...] \u0394|\u03bc| vs QM (Debye): 0.000222 Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows.","title":"Typical output"},{"location":"workflows/dipole-cross-validation/#parity-visualisation","text":"The example notebook in notebooks/ produces a parity plot comparing the QM dipole magnitude against the TeraChem ESP reconstruction across every frame. The figure below highlights the excellent agreement and annotates the RMSE. Colours denote the absolute deviation |\u0394| in Debye.","title":"Parity visualisation"},{"location":"workflows/dipole-cross-validation/#programmatic-use","text":"See tests/test_dipole.py for a complete, importable example. The test implements _three_dipoles_for_frame inline so you can copy it into your own workflow if the CLI output is not sufficient.","title":"Programmatic use"},{"location":"workflows/esp-charge-distributions/","text":"ESP Charge Distributions The notebook in notebooks/ that accompanies this project aggregates the ESP-unrestrained charges from every frame in resp.out . Two views are especially useful when sanity-checking how individual atoms sample the RESP charge distribution throughout a trajectory. Per-atom histograms The figure below overlays the histograms for every nitrogen (blue tones) and oxygen (orange tones) atom. Each trace corresponds to one atom index, so you can spot outliers or unusually broad distributions at a glance. The compact support and narrow widths suggest that the ESP-unrestrained fit is stable across the frames considered. Gaussian fits The same notebook fits a normal distribution to each atom\u2019s samples and overlays the resulting curves. This makes it easy to compare the mean and spread across similar atoms. The legend in the notebook lists the fitted mean (\u03bc) and standard deviation (\u03c3) for each atom, providing quick access to quantitative summaries that can be reused in downstream analyses.","title":"ESP Charge Distributions"},{"location":"workflows/esp-charge-distributions/#esp-charge-distributions","text":"The notebook in notebooks/ that accompanies this project aggregates the ESP-unrestrained charges from every frame in resp.out . Two views are especially useful when sanity-checking how individual atoms sample the RESP charge distribution throughout a trajectory.","title":"ESP Charge Distributions"},{"location":"workflows/esp-charge-distributions/#per-atom-histograms","text":"The figure below overlays the histograms for every nitrogen (blue tones) and oxygen (orange tones) atom. Each trace corresponds to one atom index, so you can spot outliers or unusually broad distributions at a glance. The compact support and narrow widths suggest that the ESP-unrestrained fit is stable across the frames considered.","title":"Per-atom histograms"},{"location":"workflows/esp-charge-distributions/#gaussian-fits","text":"The same notebook fits a normal distribution to each atom\u2019s samples and overlays the resulting curves. This makes it easy to compare the mean and spread across similar atoms. The legend in the notebook lists the fitted mean (\u03bc) and standard deviation (\u03c3) for each atom, providing quick access to quantitative summaries that can be reused in downstream analyses.","title":"Gaussian fits"},{"location":"workflows/linear-esp-solver/","text":"Linear ESP Charge Solver The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in linearESPcharges.linear and is backed by numpy. Pipeline Parse Terachem RESP output with ParseRespDotOut to obtain atomic positions and RESP ESP charges for each frame. Read ESP grid points from esp.xyz . Build the design matrix A where A[i, j] = 1 / r_ij for grid point i and atom j . Solve the constrained optimization problem A q \u2248 V subject to \u03a3 q = Q with explicit_solution , a closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). It accepts an optional ridge hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability. Script entry point The scripts/compare_charges.py wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges: python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 resp.out : RESP log file containing the ESP unrestrained block. esp.xyz : grid potentials from TeraChem. 78 : number of atoms in the RESP job. --frame : zero-based frame index (use -1 for the last frame). The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality. Mathematical derivation The objective is to minimise the grid misfit while enforcing the desired total charge: \\[ \\begin{aligned} \\min_{q}\\ & \\frac{1}{2}\\lVert A q - V \\rVert_2^2 \\\\ \\text{s.t.}\\ & \\mathbf{1}^\\top q = Q. \\end{aligned} \\] Using the Lagrangian \\(\\mathcal{L}(q, \\lambda) = \\tfrac{1}{2}\\lVert A q - V \\rVert_2^2 + \\lambda (\\mathbf{1}^\\top q - Q)\\) gives the stationary conditions \\[ \\nabla_q \\mathcal{L} = A^\\top(Aq - V) + \\lambda\\,\\mathbf{1} = 0,\\qquad \\nabla_\\lambda \\mathcal{L} = \\mathbf{1}^\\top q - Q = 0. \\] Defining \\(H = A^\\top A\\) and \\(g = A^\\top V\\) leads to the Karush\u2013Kuhn\u2013Tucker system \\[ \\begin{pmatrix} H & \\mathbf{1} \\\\ \\mathbf{1}^\\top & 0 \\end{pmatrix} \\begin{pmatrix} q \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} g \\\\ Q \\end{pmatrix}. \\] Rather than solving the \\((N+1)\\times(N+1)\\) block system directly, the implementation projects the unconstrained least-squares solution onto the charge-conserving hyperplane: Solve \\(H q_0 = g\\) to obtain the unconstrained solution ( q0 ). Solve \\(H c = \\mathbf{1}\\) for the correction direction ( c ). Compute \\(\\alpha = \\mathbf{1}^\\top c\\) and \\(s = \\mathbf{1}^\\top q_0\\) . Project: \\(q = q_0 - \\frac{s - Q}{\\alpha}\\, c\\) . If numerical damping is requested, \\(H\\) is replaced with \\(H + \\eta I\\) (with a small \\(\\eta > 0\\) ) in the two linear solves above. The procedure yields the same result as the full KKT solve but avoids explicitly forming the block matrix. Programmatic use You can access the components directly: from linearESPcharges.linear import prepare_linear_system, explicit_solution A, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1) solver = explicit_solution(ridge=0.0) result = solver.fit(A, V, Q) print(result[\"rmse\"], result[\"sum_q\"]) The returned dictionary includes the fitted charges q , intermediate matrices, RMSE/RRMS, and the enforced total charge.","title":"Linear ESP Solver"},{"location":"workflows/linear-esp-solver/#linear-esp-charge-solver","text":"The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in linearESPcharges.linear and is backed by numpy.","title":"Linear ESP Charge Solver"},{"location":"workflows/linear-esp-solver/#pipeline","text":"Parse Terachem RESP output with ParseRespDotOut to obtain atomic positions and RESP ESP charges for each frame. Read ESP grid points from esp.xyz . Build the design matrix A where A[i, j] = 1 / r_ij for grid point i and atom j . Solve the constrained optimization problem A q \u2248 V subject to \u03a3 q = Q with explicit_solution , a closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). It accepts an optional ridge hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability.","title":"Pipeline"},{"location":"workflows/linear-esp-solver/#script-entry-point","text":"The scripts/compare_charges.py wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges: python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 resp.out : RESP log file containing the ESP unrestrained block. esp.xyz : grid potentials from TeraChem. 78 : number of atoms in the RESP job. --frame : zero-based frame index (use -1 for the last frame). The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality.","title":"Script entry point"},{"location":"workflows/linear-esp-solver/#mathematical-derivation","text":"The objective is to minimise the grid misfit while enforcing the desired total charge: \\[ \\begin{aligned} \\min_{q}\\ & \\frac{1}{2}\\lVert A q - V \\rVert_2^2 \\\\ \\text{s.t.}\\ & \\mathbf{1}^\\top q = Q. \\end{aligned} \\] Using the Lagrangian \\(\\mathcal{L}(q, \\lambda) = \\tfrac{1}{2}\\lVert A q - V \\rVert_2^2 + \\lambda (\\mathbf{1}^\\top q - Q)\\) gives the stationary conditions \\[ \\nabla_q \\mathcal{L} = A^\\top(Aq - V) + \\lambda\\,\\mathbf{1} = 0,\\qquad \\nabla_\\lambda \\mathcal{L} = \\mathbf{1}^\\top q - Q = 0. \\] Defining \\(H = A^\\top A\\) and \\(g = A^\\top V\\) leads to the Karush\u2013Kuhn\u2013Tucker system \\[ \\begin{pmatrix} H & \\mathbf{1} \\\\ \\mathbf{1}^\\top & 0 \\end{pmatrix} \\begin{pmatrix} q \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} g \\\\ Q \\end{pmatrix}. \\] Rather than solving the \\((N+1)\\times(N+1)\\) block system directly, the implementation projects the unconstrained least-squares solution onto the charge-conserving hyperplane: Solve \\(H q_0 = g\\) to obtain the unconstrained solution ( q0 ). Solve \\(H c = \\mathbf{1}\\) for the correction direction ( c ). Compute \\(\\alpha = \\mathbf{1}^\\top c\\) and \\(s = \\mathbf{1}^\\top q_0\\) . Project: \\(q = q_0 - \\frac{s - Q}{\\alpha}\\, c\\) . If numerical damping is requested, \\(H\\) is replaced with \\(H + \\eta I\\) (with a small \\(\\eta > 0\\) ) in the two linear solves above. The procedure yields the same result as the full KKT solve but avoids explicitly forming the block matrix.","title":"Mathematical derivation"},{"location":"workflows/linear-esp-solver/#programmatic-use","text":"You can access the components directly: from linearESPcharges.linear import prepare_linear_system, explicit_solution A, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1) solver = explicit_solution(ridge=0.0) result = solver.fit(A, V, Q) print(result[\"rmse\"], result[\"sum_q\"]) The returned dictionary includes the fitted charges q , intermediate matrices, RMSE/RRMS, and the enforced total charge.","title":"Programmatic use"}]}