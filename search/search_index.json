{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"biliresp Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for Terachem, a linear-ESP (raw, unrestrained) charge constraint optimization solver, examples for validating dipoles, and a mass-weighted center-of-mass calculator that can operate on RESP or xyz geometries. Use the navigation to find quick-start installation instructions and focused walkthroughs for the two shipped command-line entry points: Fitting charges with the linear ESP solver. Cross-validating dipoles between RESP and fitted charges (and reconciling centers of mass) using the helper in scripts/print_dipoles.py or the reference implementation in tests/test_dipole.py .","title":"Home"},{"location":"#biliresp","text":"Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for Terachem, a linear-ESP (raw, unrestrained) charge constraint optimization solver, examples for validating dipoles, and a mass-weighted center-of-mass calculator that can operate on RESP or xyz geometries. Use the navigation to find quick-start installation instructions and focused walkthroughs for the two shipped command-line entry points: Fitting charges with the linear ESP solver. Cross-validating dipoles between RESP and fitted charges (and reconciling centers of mass) using the helper in scripts/print_dipoles.py or the reference implementation in tests/test_dipole.py .","title":"biliresp"},{"location":"getting-started/","text":"Getting Started Prerequisites Python 3.9 or newer. A virtual environment to isolate dependencies is recommended. python -m venv .venv source .venv/bin/activate Install the package Install the project in editable mode so that local code changes are reflected immediately: python -m pip install -e . Run the test suite Pytest expects the src/ directory on PYTHONPATH so the package can be located: PYTHONPATH=src pytest -s tests Use -k to narrow to a single test module when iterating, for example: PYTHONPATH=src pytest -s tests/test_dipole.py","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Python 3.9 or newer. A virtual environment to isolate dependencies is recommended. python -m venv .venv source .venv/bin/activate","title":"Prerequisites"},{"location":"getting-started/#install-the-package","text":"Install the project in editable mode so that local code changes are reflected immediately: python -m pip install -e .","title":"Install the package"},{"location":"getting-started/#run-the-test-suite","text":"Pytest expects the src/ directory on PYTHONPATH so the package can be located: PYTHONPATH=src pytest -s tests Use -k to narrow to a single test module when iterating, for example: PYTHONPATH=src pytest -s tests/test_dipole.py","title":"Run the test suite"},{"location":"workflows/dipole-cross-validation/","text":"Dipole Cross-Validation The helper implemented in scripts/print_dipoles.py (and mirrored inside tests/test_dipole.py ) compares three sets of dipole moments for a selected frame of a RESP run: QM dipole reported directly by TeraChem. TeraChem dipole reconstructed from the ESP-unrestrained charges written in resp.out . Lagrange dipole generated from the fitted charges returned by the linear ESP solver. The helper parses the frame in resp.out , converts the logged center of mass to bohr, and computes dipoles in Debye via: \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] with coordinates expressed in bohr. It also reports a mass-weighted center of mass derived from the supplied geometry .xyz file; you can override the coordinates (\u00c5 or bohr) when calling center_of_mass_bohr_from_xyz if you need to reuse RESP geometries directly. The return dictionary contains each dipole vector/magnitude, their deltas relative to the QM reference, and both COM estimates. Script entry point scripts/print_dipoles.py bundles the full workflow: python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz data/raw/1.pose.xyz 78 --frame -1 The script builds the linear system, fits charges with the explicit Lagrange projection, and prints the QM, TeraChem, and Lagrange dipoles plus their deltas. --frame chooses which RESP frame to analyze ( -1 = last). The geometry .xyz supplies element ordering for mass lookup when computing the mass-weighted COM. Typical output QM (from resp.out log) vector (Debye): [-0.123 ...] |\u03bc| (Debye): 2.345678 Terachem charges (RESP log) vector (Debye): [-0.121 ...] |\u03bc| (Debye): 2.346100 \u0394 vector vs QM (Debye): [0.002 ...] \u0394|\u03bc| vs QM (Debye): 0.000422 Lagrange multiplier fit (explicit) vector (Debye): [-0.120 ...] |\u03bc| (Debye): 2.345900 \u0394 vector vs QM (Debye): [0.003 ...] \u0394|\u03bc| vs QM (Debye): 0.000222 Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows. Programmatic use See tests/test_dipole.py for a complete, importable example. The test implements _three_dipoles_for_frame inline so you can copy it into your own workflow if the CLI output is not sufficient.","title":"Dipole Cross-Validation"},{"location":"workflows/dipole-cross-validation/#dipole-cross-validation","text":"The helper implemented in scripts/print_dipoles.py (and mirrored inside tests/test_dipole.py ) compares three sets of dipole moments for a selected frame of a RESP run: QM dipole reported directly by TeraChem. TeraChem dipole reconstructed from the ESP-unrestrained charges written in resp.out . Lagrange dipole generated from the fitted charges returned by the linear ESP solver. The helper parses the frame in resp.out , converts the logged center of mass to bohr, and computes dipoles in Debye via: \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] with coordinates expressed in bohr. It also reports a mass-weighted center of mass derived from the supplied geometry .xyz file; you can override the coordinates (\u00c5 or bohr) when calling center_of_mass_bohr_from_xyz if you need to reuse RESP geometries directly. The return dictionary contains each dipole vector/magnitude, their deltas relative to the QM reference, and both COM estimates.","title":"Dipole Cross-Validation"},{"location":"workflows/dipole-cross-validation/#script-entry-point","text":"scripts/print_dipoles.py bundles the full workflow: python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz data/raw/1.pose.xyz 78 --frame -1 The script builds the linear system, fits charges with the explicit Lagrange projection, and prints the QM, TeraChem, and Lagrange dipoles plus their deltas. --frame chooses which RESP frame to analyze ( -1 = last). The geometry .xyz supplies element ordering for mass lookup when computing the mass-weighted COM.","title":"Script entry point"},{"location":"workflows/dipole-cross-validation/#typical-output","text":"QM (from resp.out log) vector (Debye): [-0.123 ...] |\u03bc| (Debye): 2.345678 Terachem charges (RESP log) vector (Debye): [-0.121 ...] |\u03bc| (Debye): 2.346100 \u0394 vector vs QM (Debye): [0.002 ...] \u0394|\u03bc| vs QM (Debye): 0.000422 Lagrange multiplier fit (explicit) vector (Debye): [-0.120 ...] |\u03bc| (Debye): 2.345900 \u0394 vector vs QM (Debye): [0.003 ...] \u0394|\u03bc| vs QM (Debye): 0.000222 Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows.","title":"Typical output"},{"location":"workflows/dipole-cross-validation/#programmatic-use","text":"See tests/test_dipole.py for a complete, importable example. The test implements _three_dipoles_for_frame inline so you can copy it into your own workflow if the CLI output is not sufficient.","title":"Programmatic use"},{"location":"workflows/linear-esp-solver/","text":"Linear ESP Charge Solver The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in linearESPcharges.linear and is backed by numpy. Pipeline Parse Terachem RESP output with ParseRespDotOut to obtain atomic positions and RESP ESP charges for each frame. Read ESP grid points from esp.xyz . Build the design matrix A where A[i, j] = 1 / r_ij for grid point i and atom j . Solve the constrained optimization problem A q \u2248 V subject to \u03a3 q = Q with explicit_solution , a closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). It accepts an optional ridge hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability. Script entry point The scripts/compare_charges.py wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges: python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 resp.out : RESP log file containing the ESP unrestrained block. esp.xyz : grid potentials from TeraChem. 78 : number of atoms in the RESP job. --frame : zero-based frame index (use -1 for the last frame). The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality. Programmatic use You can access the components directly: from linearESPcharges.linear import prepare_linear_system, explicit_solution A, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1) solver = explicit_solution(ridge=0.0) result = solver.fit(A, V, Q) print(result[\"rmse\"], result[\"sum_q\"]) The returned dictionary includes the fitted charges q , intermediate matrices, RMSE/RRMS, and the enforced total charge.","title":"Linear ESP Solver"},{"location":"workflows/linear-esp-solver/#linear-esp-charge-solver","text":"The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in linearESPcharges.linear and is backed by numpy.","title":"Linear ESP Charge Solver"},{"location":"workflows/linear-esp-solver/#pipeline","text":"Parse Terachem RESP output with ParseRespDotOut to obtain atomic positions and RESP ESP charges for each frame. Read ESP grid points from esp.xyz . Build the design matrix A where A[i, j] = 1 / r_ij for grid point i and atom j . Solve the constrained optimization problem A q \u2248 V subject to \u03a3 q = Q with explicit_solution , a closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). It accepts an optional ridge hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability.","title":"Pipeline"},{"location":"workflows/linear-esp-solver/#script-entry-point","text":"The scripts/compare_charges.py wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges: python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 resp.out : RESP log file containing the ESP unrestrained block. esp.xyz : grid potentials from TeraChem. 78 : number of atoms in the RESP job. --frame : zero-based frame index (use -1 for the last frame). The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality.","title":"Script entry point"},{"location":"workflows/linear-esp-solver/#programmatic-use","text":"You can access the components directly: from linearESPcharges.linear import prepare_linear_system, explicit_solution A, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1) solver = explicit_solution(ridge=0.0) result = solver.fit(A, V, Q) print(result[\"rmse\"], result[\"sum_q\"]) The returned dictionary includes the fitted charges q , intermediate matrices, RMSE/RRMS, and the enforced total charge.","title":"Programmatic use"}]}