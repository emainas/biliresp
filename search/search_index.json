{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"biliresp Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for Terachem, a linear-ESP (raw, unrestrained) charge constraint optimization solver, and dipole validation helpers with friendly tests and scripts. Use the navigation to find quick-start installation instructions and focused walkthroughs for the two shipped command-line entry points: Fitting charges with the linear ESP solver. Cross-validating dipoles between RESP and fitted charges.","title":"Home"},{"location":"#biliresp","text":"Utilities for analyzing electrostatic potential (ESP) outputs. The project includes a RESP parser for Terachem, a linear-ESP (raw, unrestrained) charge constraint optimization solver, and dipole validation helpers with friendly tests and scripts. Use the navigation to find quick-start installation instructions and focused walkthroughs for the two shipped command-line entry points: Fitting charges with the linear ESP solver. Cross-validating dipoles between RESP and fitted charges.","title":"biliresp"},{"location":"getting-started/","text":"Getting Started Prerequisites Python 3.9 or newer. A virtual environment to isolate dependencies is recommended. python -m venv .venv source .venv/bin/activate Install the package Install the project in editable mode so that local code changes are reflected immediately: python -m pip install -e . Run the test suite Pytest expects the src/ directory on PYTHONPATH so the package can be located: PYTHONPATH=src pytest -s tests Use -k to narrow to a single test module when iterating, for example: PYTHONPATH=src pytest -s tests/test_dipole.py","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Python 3.9 or newer. A virtual environment to isolate dependencies is recommended. python -m venv .venv source .venv/bin/activate","title":"Prerequisites"},{"location":"getting-started/#install-the-package","text":"Install the project in editable mode so that local code changes are reflected immediately: python -m pip install -e .","title":"Install the package"},{"location":"getting-started/#run-the-test-suite","text":"Pytest expects the src/ directory on PYTHONPATH so the package can be located: PYTHONPATH=src pytest -s tests Use -k to narrow to a single test module when iterating, for example: PYTHONPATH=src pytest -s tests/test_dipole.py","title":"Run the test suite"},{"location":"workflows/dipole-cross-validation/","text":"Dipole Cross-Validation dipole.three_dipoles_last_frame compares three sets of dipole moments for the final frame of a RESP run: QM dipole reported directly by Terachem. ESP unrestrained dipole computed from RESP's own ESP charges. Optimized dipole generated from your fitted charges. The function parses the last \"ESP unrestrained charges\" block, the center of mass, and the dipole magnitude/vector from resp.out , then computes dipoles in Debye via: \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] with coordinates expressed in bohr. It returns a dictionary containing the vectors, magnitudes, and the deltas relative to the QM reference. Script entry point scripts/print_dipoles.py bundles the full workflow: python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 --solver explicit The script builds the linear system, fits charges ( explicit or kkt ), and prints the QM, ESP, and optimized dipole magnitudes along with delta vectors. --frame chooses which RESP frame to analyze ( -1 = last); --solver swaps between the two solvers exported from linearESPcharges . Typical output QM (from resp.out log) vector (Debye): [-0.123 ...] |\u03bc| (Debye): 2.345678 ESP unrestrained charges vector (Debye): [-0.121 ...] |\u03bc| (Debye): 2.346100 \u0394 vector vs QM (Debye): [0.002 ...] \u0394|\u03bc| vs QM (Debye): 0.000422 Fitted charges (explicit) vector (Debye): [-0.120 ...] |\u03bc| (Debye): 2.345900 \u0394 vector vs QM (Debye): [0.003 ...] \u0394|\u03bc| vs QM (Debye): 0.000222 Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows. Programmatic use from dipole import three_dipoles_last_frame # Assume you already prepared A, V, Q, resp_charges, coords_bohr via prepare_linear_system(..., return_positions=True) dipoles = three_dipoles_last_frame(\"data/raw/resp.out\", coords_bohr, fitted_result[\"q\"]) print(dipoles[\"optimized_dipole_mag_D\"], dipoles[\"delta_opt_vs_qm_mag_D\"])","title":"Dipole Cross-Validation"},{"location":"workflows/dipole-cross-validation/#dipole-cross-validation","text":"dipole.three_dipoles_last_frame compares three sets of dipole moments for the final frame of a RESP run: QM dipole reported directly by Terachem. ESP unrestrained dipole computed from RESP's own ESP charges. Optimized dipole generated from your fitted charges. The function parses the last \"ESP unrestrained charges\" block, the center of mass, and the dipole magnitude/vector from resp.out , then computes dipoles in Debye via: \\[ \\mu = \\sum_A q_A (R_A - R_{\\text{COM}}) \\] with coordinates expressed in bohr. It returns a dictionary containing the vectors, magnitudes, and the deltas relative to the QM reference.","title":"Dipole Cross-Validation"},{"location":"workflows/dipole-cross-validation/#script-entry-point","text":"scripts/print_dipoles.py bundles the full workflow: python scripts/print_dipoles.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 --solver explicit The script builds the linear system, fits charges ( explicit or kkt ), and prints the QM, ESP, and optimized dipole magnitudes along with delta vectors. --frame chooses which RESP frame to analyze ( -1 = last); --solver swaps between the two solvers exported from linearESPcharges .","title":"Script entry point"},{"location":"workflows/dipole-cross-validation/#typical-output","text":"QM (from resp.out log) vector (Debye): [-0.123 ...] |\u03bc| (Debye): 2.345678 ESP unrestrained charges vector (Debye): [-0.121 ...] |\u03bc| (Debye): 2.346100 \u0394 vector vs QM (Debye): [0.002 ...] \u0394|\u03bc| vs QM (Debye): 0.000422 Fitted charges (explicit) vector (Debye): [-0.120 ...] |\u03bc| (Debye): 2.345900 \u0394 vector vs QM (Debye): [0.003 ...] \u0394|\u03bc| vs QM (Debye): 0.000222 Use this readout to sanity-check that your fitted charges reproduce the QM dipole within an acceptable tolerance before exporting them to downstream workflows.","title":"Typical output"},{"location":"workflows/dipole-cross-validation/#programmatic-use","text":"from dipole import three_dipoles_last_frame # Assume you already prepared A, V, Q, resp_charges, coords_bohr via prepare_linear_system(..., return_positions=True) dipoles = three_dipoles_last_frame(\"data/raw/resp.out\", coords_bohr, fitted_result[\"q\"]) print(dipoles[\"optimized_dipole_mag_D\"], dipoles[\"delta_opt_vs_qm_mag_D\"])","title":"Programmatic use"},{"location":"workflows/linear-esp-solver/","text":"Linear ESP Charge Solver The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in linearESPcharges.linear and is backed by numpy. Pipeline Parse Terachem RESP output with ParseRespDotOut to obtain atomic positions and RESP ESP charges for each frame. Read ESP grid points from esp.xyz . Build the design matrix A where A[i, j] = 1 / r_ij for grid point i and atom j . Solve the constrained optimization problem A q \u2248 V subject to \u03a3 q = Q using one of two solvers: explicit_solution : closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). KKTblock_solution : solves the block matrix from the Karush\u2013Kuhn\u2013Tucker conditions in a single shot. Both solvers accept an optional ridge hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability. Script entry point The scripts/compare_charges.py wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges: python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 --solver explicit resp.out : RESP log file containing the ESP unrestrained block. esp.xyz : grid potentials from TeraChem. 78 : number of atoms in the RESP job. --frame : zero-based frame index (use -1 for the last frame). --solver : either explicit (default) or kkt . The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality. Programmatic use You can access the components directly: from linearESPcharges.linear import prepare_linear_system, explicit_solution A, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1) solver = explicit_solution(ridge=0.0) result = solver.fit(A, V, Q) print(result[\"rmse\"], result[\"sum_q\"]) The returned dictionary includes the fitted charges q , intermediate matrices, RMSE/RRMS, and the enforced total charge.","title":"Linear ESP Solver"},{"location":"workflows/linear-esp-solver/#linear-esp-charge-solver","text":"The linear solver fits electrostatic potential (ESP) charges that reproduce grid values exported by RESP/TeraChem. Everything lives in linearESPcharges.linear and is backed by numpy.","title":"Linear ESP Charge Solver"},{"location":"workflows/linear-esp-solver/#pipeline","text":"Parse Terachem RESP output with ParseRespDotOut to obtain atomic positions and RESP ESP charges for each frame. Read ESP grid points from esp.xyz . Build the design matrix A where A[i, j] = 1 / r_ij for grid point i and atom j . Solve the constrained optimization problem A q \u2248 V subject to \u03a3 q = Q using one of two solvers: explicit_solution : closed-form projection that first finds the unconstrained least squares solution and then enforces the total charge (Lagrange multiplier method). KKTblock_solution : solves the block matrix from the Karush\u2013Kuhn\u2013Tucker conditions in a single shot. Both solvers accept an optional ridge hyper-parameter if you want to add a small diagonal Tikhonov term for numerical stability.","title":"Pipeline"},{"location":"workflows/linear-esp-solver/#script-entry-point","text":"The scripts/compare_charges.py wrapper prepares the system and prints per-atom differences between RESP unrestrained charges and the fitted charges: python scripts/compare_charges.py data/raw/resp.out data/raw/esp.xyz 78 --frame -1 --solver explicit resp.out : RESP log file containing the ESP unrestrained block. esp.xyz : grid potentials from TeraChem. 78 : number of atoms in the RESP job. --frame : zero-based frame index (use -1 for the last frame). --solver : either explicit (default) or kkt . The output lists each atom index with the RESP charge, the fitted charge, and the difference. A footer prints charge conservation, RMSE, and RRMS metrics so you can quickly gauge the fit quality.","title":"Script entry point"},{"location":"workflows/linear-esp-solver/#programmatic-use","text":"You can access the components directly: from linearESPcharges.linear import prepare_linear_system, explicit_solution A, V, Q, resp_charges = prepare_linear_system(\"data/raw/resp.out\", \"data/raw/esp.xyz\", 78, frame_index=-1) solver = explicit_solution(ridge=0.0) result = solver.fit(A, V, Q) print(result[\"rmse\"], result[\"sum_q\"]) The returned dictionary includes the fitted charges q , intermediate matrices, RMSE/RRMS, and the enforced total charge.","title":"Programmatic use"}]}